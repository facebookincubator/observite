// Generated by dts-bundle-generator v9.5.1

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
export type Maybe<T> = T | null | undefined;
declare enum ComparisonMethod {
	Exact = 0,
	ShallowEqual = 1,
	DeepEquals = 2
}
declare enum Status {
	Pending = 0,
	Resolved = 1,
	Rejected = 2
}
declare enum ThrowMode {
	ErrorOnPending = 0,
	ThrowPromise = 1
}
/**
 * Whether using async or sync state, we treat the state as if it is async.
 * Sync state simply never enters the Status.Pending status.
 */
export type AsyncState<TResolve> = {
	status: Status.Pending;
	promise: Promise<TResolve>;
} | {
	status: Status.Resolved;
	result: TResolve;
} | {
	status: Status.Rejected;
	error: Error;
};
export type StatusChangeCB = (next: Status, prev: Status) => unknown;
/**
 * Because we want to support nullable types, we can't simply hold a value and
 * perform null checks against it. Instead, we need a wrapper that indicates
 * whether the value was provided at all or if the value was provided but is
 * null itself.
 */
export type HolderForProvided<TProvide> = {
	provided: TProvide;
};
declare abstract class AbstractStateRef<TResolve, TProvide> {
	private holder;
	private state;
	private onStatusChanged;
	constructor(holder: Maybe<HolderForProvided<TProvide>>, state: AsyncState<TResolve>, onStatusChanged?: Maybe<StatusChangeCB>);
	getStatus(): Status;
	getState(): Readonly<AsyncState<TResolve>>;
	protected setState(state: AsyncState<TResolve>): void;
	getHolderForProvided(): Maybe<HolderForProvided<TProvide>>;
	/**
	 * Allows Observables to inspect the data without subscribing or modifying it.
	 * The peek method does not provide context about the Promise or error status;
	 * it simply returns the value if available.
	 */
	peek(): Maybe<TResolve>;
	/**
	 * Returns the provided value if the status is Status.Pending or Status.Resolved.
	 * Throws an error if the status is Status.Rejected.
	 */
	getOrThrowProvided(): TProvide;
	/**
	 * Returns the result if available, otherwise the provided value.
	 * Throws an error only if the status is Status.Rejected.
	 */
	getOrThrowAsync(): TProvide | TResolve;
	/**
	 * Throws if the status is not 'Resolved'. Handles promises based on the mode:
	 * - ThrowMode.ErrorOnPending: Throws an error if pending
	 * - ThrowMode.ThrowPromise: Throws the promise itself if pending
	 */
	getOrThrowSync(mode: ThrowMode): TResolve;
}
declare class AsyncStateRef<TResolve, TProvide extends Promise<TResolve>> extends AbstractStateRef<TResolve, TProvide> {
	promise: Promise<TResolve>;
	constructor(promise: TProvide, onStatusChanged?: Maybe<StatusChangeCB>);
}
declare class SyncStateRef<TResolve, TProvide> extends AbstractStateRef<TResolve, TProvide> {
	constructor(result: TProvide & TResolve, onStatusChanged?: Maybe<StatusChangeCB>);
}
export type StateRef<TResolve, TProvide> = TProvide extends Promise<TResolve> ? AsyncStateRef<TResolve, TProvide> : SyncStateRef<TResolve, TProvide>;
export declare class Observable<TResolve, TProvide extends TResolve = TResolve> extends TAbstractObservable<TResolve, TProvide> {
	static factory: <TResolveF, TProvideF extends TResolveF = TResolveF>(options?: Maybe<ObservableOptions<TProvideF>>) => Observable<TResolveF, TProvideF>;
}
/**
 * Callback that creates a default value for a given key
 */
export type getDefaultCB<TKey, TProvide> = (key: TKey) => TProvide;
/**
 * Options are the same as for an Observable, but onRelease needs to include a key
 */
export type ObservableMapOptions<TKey, TProvide> = Omit<ObservableOptions<TProvide>, "onRelease"> & Partial<{
	onRelease: (key: TKey, provide: TProvide) => void;
}>;
declare abstract class AbstractObservableMap<TKey, TResolve, TProvide, TObservable extends TAbstractObservable<TResolve, TProvide> = TAbstractObservable<TResolve, TProvide>> {
	private debugIdPrefix;
	protected map: Observable<Map<TKey, TObservable>>;
	private getDefault;
	private options;
	private makeObservable;
	constructor(getDefault: Maybe<getDefaultCB<TKey, TProvide>>, valueOptions: Maybe<ObservableMapOptions<TKey, TProvide>>, makeObservable: (options: ObservableOptions<TProvide>) => TObservable);
	setDebugPrefix: (prefix: string) => void;
	/**
	 * Retrieves the state associated with the given key if it exists and, in the case
	 * of an async map, if the Promise has resolved. This method will not create a default
	 * entry, even if a default has been set. Note that if the map contains nullable types,
	 * using `peek` alone is insufficient to determine whether the state is `null` or if
	 * the state does not exist.
	 */
	peek: (key: TKey) => Maybe<TResolve>;
	peekEntries: () => Maybe<Array<[
		TKey,
		Maybe<TResolve>
	]>>;
	/**
	 * Updates the value associated with the given key and notifies observers
	 * of the change.
	 */
	set: (key: TKey, value: TProvide) => void;
	has(key: TKey): boolean;
	/**
	 * Removes all items from the map.
	 */
	clear(): void;
	/**
	 * Used by Observers and Observables to access the StateRef for a given key.
	 * Should only be accessed internally
	 */
	__observeRef: (observer: AbstractObserver, key: TKey) => Maybe<StateRef<TResolve, TProvide>>;
	/**
	 * Internal setter that creates the observable for a given key if missing.
	 */
	private setImpl;
}
export declare class AsyncObserver extends AbstractObserver {
	static factory: () => AsyncObserver;
	observe: <TResolve, TProvide>(observable: AnyObservable<TResolve, TProvide>) => TResolve | TProvide;
	observeKey: <TKey, TResolve, TProvide>(observable: AnyObservableMap<TKey, TResolve, TProvide>, key: TKey) => Maybe<TResolve | TProvide>;
}
declare class SyncObserver extends AbstractObserver {
	static factory: () => SyncObserver;
	observe: <TResolve, TProvide>(observable: AnyObservable<TResolve, TProvide>) => TResolve;
	observeKey: <TKey, TResolve, TProvide>(observable: AnyObservableMap<TKey, TResolve, TProvide>, key: TKey) => Maybe<TResolve>;
}
export type AnyObserver = AsyncObserver | SyncObserver;
export type getStateCB<TResolve, TProvide, TObserver> = (observer: TObserver, previous: Maybe<TResolve>) => TProvide;
declare abstract class AbstractSelector<TResolve, TProvide, TObserver extends AnyObserver, TObservable extends TAbstractObservable<TResolve, TProvide> = TAbstractObservable<TResolve, TProvide>> {
	private debugID;
	private getState;
	private stateObserver;
	private stateObservable;
	constructor(getState: getStateCB<TResolve, TProvide, TObserver>, options: Maybe<ObservableOptions<TProvide>>, createObserver: () => TObserver, createObservable: (options: ObservableOptions<TProvide>) => TObservable);
	setDebugPrefix: (prefix: string) => void;
	/**
	 * Cleans up the state when removing all references to this selector.
	 */
	destroy(): void;
	/**
	 * Retrieves the cached state if it exists from an observer's request.
	 * This method will not generate the state if it is missing. Note that if
	 * the selector is for a nullable type, using peek alone is insufficient to
	 * determine whether the state is null or does not exist.
	 */
	peek: () => Maybe<TResolve>;
	peekSafe: () => Maybe<TResolve>;
	/**
	 * Although selectors are downstream from observables, it can sometimes be
	 * convenient to have a setter that accepts the same value provided by getState.
	 * This setter would internally determine what needs to be updated so that
	 * getState will subsequently provide that value.
	 */
	set: (_: TProvide) => never;
	/**
	 * Used by Observers and Observables to access the StateRef.
	 */
	__observeRef: (observer: AbstractObserver) => StateRef<TResolve, TProvide>;
	/**
	 * Calls the getState callback and caches the result.
	 */
	private updateState;
}
export declare class AsyncSelector<TResolve, TProvide extends Promise<TResolve> = Promise<TResolve>> extends AbstractSelector<TResolve, TProvide, AsyncObserver> {
	static factory: <TResolveF, TProvideF extends Promise<TResolveF> = Promise<TResolveF>>(getState: getStateCB<TResolveF, TProvideF, AsyncObserver>, options: Maybe<ObservableOptions<TProvideF>>) => AsyncSelector<TResolveF, TProvideF>;
	constructor(getState: getStateCB<TResolve, TProvide, AsyncObserver>, options?: Maybe<ObservableOptions<TProvide>>);
}
export declare class AsyncObservableMap<TKey, TResolve, TProvide extends Promise<TResolve> = Promise<TResolve>> extends AbstractObservableMap<TKey, TResolve, TProvide> {
	constructor(getDefault?: Maybe<getDefaultCB<TKey, TProvide>>, valueOptions?: Maybe<ObservableMapOptions<TKey, TProvide>>);
	/**
	 * Convenience selector that can be used to access all items in the map
	 */
	entries: AsyncSelector<Array<[
		TKey,
		TResolve
	]>>;
}
/**
 * Callback that selects state for a given key
 */
export type getKeyStateCB<TKey, TProvide> = (Observer: AnyObserver, TKey: TKey) => TProvide;
/**
 * Same options as observable however the release function needs a key
 */
export type SelectorMapOptions<TKey, TProvide> = Omit<ObservableOptions<TProvide>, "onRelease"> & Partial<{
	onRelease: (key: TKey, provide: TProvide) => void;
}>;
declare abstract class AbstractSelectorMap<TKey, TResolve, TProvide, TObserver extends AnyObserver, TSelector extends AbstractSelector<TResolve, TProvide, TObserver> = AbstractSelector<TResolve, TProvide, TObserver>> {
	private debugIdPrefix;
	private selectors;
	private getState;
	private options;
	private createSelector;
	constructor(getState: getKeyStateCB<TKey, TProvide>, options: Maybe<SelectorMapOptions<TKey, TProvide>>, createSelector: (getState: getStateCB<TResolve, TProvide, TObserver>, options: ObservableOptions<TProvide>) => TSelector);
	setDebugPrefix: (prefix: string) => void;
	/**
	 * Retrieves the cached state for a given key if it exists from an observer's request.
	 * This method will not generate the state if it is missing. Note that if the selector
	 * is for a nullable type, using peek alone is insufficient to determine whether the
	 * state is null or does not exist.
	 */
	peek: (key: TKey) => Maybe<TResolve>;
	/**
	 * Although selectors are downstream from observables, it can sometimes be
	 * convenient to have a setter that accepts the same value provided by getState.
	 * This setter would internally determine what needs to be updated so that
	 * getState will subsequently provide that new value.
	 */
	set: (_key: TKey, _provide: TProvide) => never;
	/**
	 * Used by Observers and Observables to access the StateRef for a given key.
	 */
	__observeRef: (observer: AbstractObserver, key: TKey) => StateRef<TResolve, TProvide>;
	/**
	 * Retrieves the selector associated with a given key, or creates one if it
	 * does not exist yet.
	 */
	private getSelector;
}
export declare class AsyncSelectorMap<TKey, TResolve, TProvide extends Promise<TResolve> = Promise<TResolve>> extends AbstractSelectorMap<TKey, TResolve, TProvide, AsyncObserver> {
	constructor(getState: getKeyStateCB<TKey, TProvide>, options?: Maybe<SelectorMapOptions<TKey, TProvide>>);
}
export declare class Selector<TResolve, TProvide extends TResolve = TResolve> extends AbstractSelector<TResolve, TProvide, SyncObserver> {
	static factory: <TResolveF, TProvideF extends TResolveF = TResolveF>(getState: getStateCB<TResolveF, TProvideF, SyncObserver>, options: Maybe<ObservableOptions<TProvideF>>) => Selector<TResolveF, TProvideF>;
	constructor(getState: getStateCB<TResolve, TProvide, SyncObserver>, options?: Maybe<ObservableOptions<TProvide>>);
}
export declare class ObservableMap<TKey, TResolve, TProvide extends TResolve = TResolve> extends AbstractObservableMap<TKey, TResolve, TProvide> {
	constructor(getDefault?: Maybe<getDefaultCB<TKey, TProvide>>, valueOptions?: Maybe<ObservableMapOptions<TKey, TProvide>>);
	/**
	 * Convenience selector that can be used to access all items in the map
	 */
	entries: Selector<Array<[
		TKey,
		TResolve
	]>>;
}
export declare class SelectorMap<TKey, TResolve, TProvide extends TResolve = TResolve> extends AbstractSelectorMap<TKey, TResolve, TProvide, SyncObserver> {
	constructor(getState: getKeyStateCB<TKey, TProvide>, options?: Maybe<SelectorMapOptions<TKey, TProvide>>);
}
export type AnyObservable<TResolve, TProvide> = [
	TProvide
] extends [
	TResolve
] ? AnySyncObservable<TResolve, TProvide> : [
	TProvide
] extends [
	Promise<TResolve>
] ? AnyAsyncObservable<TResolve, TProvide> : never;
export type AnySyncObservable<TResolve, TProvide extends TResolve> = Observable<TResolve, TProvide> | Selector<TResolve, TProvide>;
export type AnyAsyncObservable<TResolve, TProvide extends Promise<TResolve>> = AsyncObservable<TResolve, TProvide> | AsyncSelector<TResolve, TProvide>;
export type AnyObservableMap<TKey, TResolve, TProvide> = [
	TProvide
] extends [
	TResolve
] ? AnySyncObservableMap<TKey, TResolve, TProvide> : [
	TProvide
] extends [
	Promise<TResolve>
] ? AnyAsyncObservableMap<TKey, TResolve, TProvide> : never;
export type AnySyncObservableMap<TKey, TResolve, TProvide extends TResolve> = ObservableMap<TKey, TResolve, TProvide> | SelectorMap<TKey, TResolve, TProvide>;
export type AnyAsyncObservableMap<TKey, TResolve, TProvide extends Promise<TResolve>> = AsyncObservableMap<TKey, TResolve, TProvide> | AsyncSelectorMap<TKey, TResolve, TProvide>;
declare abstract class AbstractObserver {
	private observables;
	private onChange;
	private creationOrder;
	protected debugID: number | string;
	protected isComponent: boolean;
	constructor(debugPrefix?: Maybe<string>);
	/**
	 * Should only be called by internal systems.
	 */
	__getCreationOrder(): number;
	setDebugPrefix(prefix: number | string): void;
	setOnChange(onChange: () => void): void;
	getIsComponent(): boolean;
	/**
	 * Called when the Observer is no longer needed. Cleans up any resources.
	 */
	destroy(): void;
	/**
	 * Called to clear subscriptions to all Observables.
	 */
	reset(): void;
	observeState: <TResolve, TProvide>(observable: AnyObservable<TResolve, TProvide>) => Readonly<AsyncState<TResolve>>;
	observeKeyState: <TKey, TResolve, TProvide>(observable: AnyObservableMap<TKey, TResolve, TProvide>, key: TKey) => Maybe<Readonly<AsyncState<TResolve>>>;
	/**
	 * Should only be called by internal systems.
	 */
	__addObservable(observable: AbstractObservable): void;
	/**
	 * Should only be called by internal systems.
	 */
	__observableChanged(): void;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Since ReleaseDelay is a union type that includes a number for exact release
 * delays, we need to use a string literal to ensure type safety.
 */
export declare enum ReleaseDelay {
	Default = "Default",
	Never = "Never"
}
/**
 * Options you can provide to an Observable
 */
export type ObservableOptions<TProvide> = Partial<{
	default: TProvide;
	debugID: string;
	onChanged: (newValue: TProvide) => unknown;
	releaseDelay: number | ReleaseDelay;
	onRelease: (provided: TProvide) => unknown;
	comparisonMethod: ComparisonMethod;
}>;
declare abstract class AbstractObservable {
	protected debugID: number | string;
	abstract __checkForNoObservers(): void;
	abstract __removeObserver(observer: AbstractObserver): void;
	setDebugPrefix: (prefix: number | string) => void;
}
declare abstract class TAbstractObservable<TResolve, TProvide> extends AbstractObservable {
	private stateRef;
	private observers;
	private options;
	private isDestroyed;
	private releaseTimeoutID;
	constructor(options?: Maybe<ObservableOptions<TProvide>>);
	/**
	 * Checks if the state has been initialized. Accessing the state before
	 * initialization can lead to exceptions.
	 */
	isInitialized(): boolean;
	/**
	 * Cleans up the state and marks the observable as destroyed before removing
	 * references to it.
	 */
	destroy(): void;
	/**
	 * Retrieves the cached state if it exists. Throws an error if the state has
	 * not been initialized. Returns null if there was an error or if a Promise is
	 * still pending. Note that if the Observable's type is nullable, using this
	 * method alone may not distinguish between a null value and a missing value.
	 */
	peek: () => Maybe<TResolve>;
	/**
	 * Updates the value and notifies observers if the new value differs from the
	 * current value. This is defined as an arrow function to ensure it can be
	 * used directly as a callback in React components, preserving the correct
	 * `this` context.
	 */
	set: (value: TProvide) => void;
	/**
	 * Overridable method for setting the value. This method is provided to
	 * address issues with `this` binding that can occur when overriding the
	 * function expression used in the `set` method.
	 */
	protected setImpl(value: TProvide): void;
	/**
	 * Sets the state to a failed state with the provided error. Once set, this
	 * error will be thrown each time the state is observed, instead of returning
	 * a value.
	 */
	setError(error: Error): void;
	/**
	 * Allows Observers and Observables to access the StateRef for a given key.
	 * Should only be called by internal systems.
	 */
	__observeRef: (observer: AbstractObserver) => StateRef<TResolve, TProvide>;
	/**
	 * Clears the reference count for the specified observer.
	 * Should only be called by internal systems.
	 */
	__removeObserver(observer: AbstractObserver): void;
	/**
	 * Checks if the state is ready to be released and initiates a timeout to
	 * release it after the specified delay. This is used by the ObservableManager
	 * to manage state lifecycle based on observer presence.
	 */
	__checkForNoObservers(): void;
	/**
	 * Clears internal state and observers.
	 */
	private clearState;
	/**
	 * Queues observers for notification of changes, then clears all references.
	 * Observers will re-evaluate their observables after each change.
	 */
	private changed;
	/**
	 * Adds an observer and cancels any pending release.
	 */
	private addObserver;
	/**
	 * Cancels any pending release timeout if it exists.
	 */
	private resetReleaseTimeout;
	/**
	 * Frees the state reference after the specified release delay in options.
	 */
	private release;
}
export declare class AsyncObservable<TResolve, TProvide extends Promise<TResolve> = Promise<TResolve>> extends TAbstractObservable<TResolve, TProvide> {
	static factory: <TResolveF, TProvideF extends Promise<TResolveF> = Promise<TResolveF>>(options?: Maybe<ObservableOptions<TProvideF>>) => AsyncObservable<TResolveF, TProvideF>;
}
export declare class ComponentObserver extends AbstractObserver {
	private isLocked;
	protected isComponent: boolean;
	static factory: () => ComponentObserver;
	observe: <TResolve, TProvide>(observable: AnyObservable<TResolve, TProvide>) => TResolve;
	observeKey: <TKey, TResolve, TProvide>(observable: AnyObservableMap<TKey, TResolve, TProvide>, key: TKey) => Maybe<TResolve>;
	lock(): void;
	unlock(): void;
	onRender(): void;
	__addObservable(observable: AbstractObservable): void;
}
/**
 * Configuration options for the application.
 */
export type Config = {
	defaultComparisonMethod: ComparisonMethod;
	defaultReleaseDelayMS: number;
	defaultObservableReleaseDelay: ReleaseDelay | number;
	defaultSelectorReleaseDelay: ReleaseDelay | number;
	setTimeout: typeof setTimeout;
	clearTimeout: typeof clearTimeout;
	setInterval: typeof setInterval;
	clearInterval: typeof clearInterval;
	setImmediate: (cb: (...args: any[]) => void) => unknown;
};
export declare function setConfigOptions(options: Partial<Config>): void;
export type Options<T> = {
	transitionDurationMs: number;
	framesPerSecond: number;
	waitMs: number;
	interpolateCB?: <T>(start: T, end: T, t: number) => T;
};
export declare class ObservableAnimation<T> {
	target: Observable<T>;
	current: Observable<T>;
	private options;
	animationState: Maybe<{
		start: T;
		end: T;
		t: number;
		tStep: number;
		delayMs: number;
		id: ReturnType<typeof setInterval>;
	}>;
	constructor(targetOptions?: Maybe<ObservableOptions<T>>, currentOptions?: Maybe<ObservableOptions<T>>, options?: Maybe<Partial<Options<T>>>);
	setTarget(value: T): void;
	setCurrent(value: T): void;
	setBoth(value: T): void;
	destroy(): void;
	private onRelease;
	private onChanged;
	private startInterval;
	private onFrame;
	clearAnimation(): void;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Optional base class for classes containing observables.
 * Injects debug IDs into the observables for logging.
 */
export declare class ObservableStore {
	constructor();
}

export {};
